// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class AddToContractWhitelist extends ethereum.Event {
  get params(): AddToContractWhitelist__Params {
    return new AddToContractWhitelist__Params(this);
  }
}

export class AddToContractWhitelist__Params {
  _event: AddToContractWhitelist;

  constructor(event: AddToContractWhitelist) {
    this._event = event;
  }

  get _contract(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class Approval extends ethereum.Event {
  get params(): Approval__Params {
    return new Approval__Params(this);
  }
}

export class Approval__Params {
  _event: Approval;

  constructor(event: Approval) {
    this._event = event;
  }

  get owner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get spender(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get value(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class OwnershipTransferred extends ethereum.Event {
  get params(): OwnershipTransferred__Params {
    return new OwnershipTransferred__Params(this);
  }
}

export class OwnershipTransferred__Params {
  _event: OwnershipTransferred;

  constructor(event: OwnershipTransferred) {
    this._event = event;
  }

  get previousOwner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newOwner(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class RemoveFromContractWhitelist extends ethereum.Event {
  get params(): RemoveFromContractWhitelist__Params {
    return new RemoveFromContractWhitelist__Params(this);
  }
}

export class RemoveFromContractWhitelist__Params {
  _event: RemoveFromContractWhitelist;

  constructor(event: RemoveFromContractWhitelist) {
    this._event = event;
  }

  get _contract(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class RewardAdded extends ethereum.Event {
  get params(): RewardAdded__Params {
    return new RewardAdded__Params(this);
  }
}

export class RewardAdded__Params {
  _event: RewardAdded;

  constructor(event: RewardAdded) {
    this._event = event;
  }

  get token(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get rps(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class RewardClaimed extends ethereum.Event {
  get params(): RewardClaimed__Params {
    return new RewardClaimed__Params(this);
  }
}

export class RewardClaimed__Params {
  _event: RewardClaimed;

  constructor(event: RewardClaimed) {
    this._event = event;
  }

  get token(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get staker(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class RewardCollection extends ethereum.Event {
  get params(): RewardCollection__Params {
    return new RewardCollection__Params(this);
  }
}

export class RewardCollection__Params {
  _event: RewardCollection;

  constructor(event: RewardCollection) {
    this._event = event;
  }

  get token(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get addr(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class RoleAdminChanged extends ethereum.Event {
  get params(): RoleAdminChanged__Params {
    return new RoleAdminChanged__Params(this);
  }
}

export class RoleAdminChanged__Params {
  _event: RoleAdminChanged;

  constructor(event: RoleAdminChanged) {
    this._event = event;
  }

  get role(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get previousAdminRole(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }

  get newAdminRole(): Bytes {
    return this._event.parameters[2].value.toBytes();
  }
}

export class RoleGranted extends ethereum.Event {
  get params(): RoleGranted__Params {
    return new RoleGranted__Params(this);
  }
}

export class RoleGranted__Params {
  _event: RoleGranted;

  constructor(event: RoleGranted) {
    this._event = event;
  }

  get role(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get account(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get sender(): Address {
    return this._event.parameters[2].value.toAddress();
  }
}

export class RoleRevoked extends ethereum.Event {
  get params(): RoleRevoked__Params {
    return new RoleRevoked__Params(this);
  }
}

export class RoleRevoked__Params {
  _event: RoleRevoked;

  constructor(event: RoleRevoked) {
    this._event = event;
  }

  get role(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get account(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get sender(): Address {
    return this._event.parameters[2].value.toAddress();
  }
}

export class Stake extends ethereum.Event {
  get params(): Stake__Params {
    return new Stake__Params(this);
  }
}

export class Stake__Params {
  _event: Stake;

  constructor(event: Stake) {
    this._event = event;
  }

  get addr(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get multipliedAmount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class StakeMultiplier extends ethereum.Event {
  get params(): StakeMultiplier__Params {
    return new StakeMultiplier__Params(this);
  }
}

export class StakeMultiplier__Params {
  _event: StakeMultiplier;

  constructor(event: StakeMultiplier) {
    this._event = event;
  }

  get addr(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get nft(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get tokenId(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get multipliedAmount(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class Transfer extends ethereum.Event {
  get params(): Transfer__Params {
    return new Transfer__Params(this);
  }
}

export class Transfer__Params {
  _event: Transfer;

  constructor(event: Transfer) {
    this._event = event;
  }

  get from(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get to(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get value(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class Withdraw extends ethereum.Event {
  get params(): Withdraw__Params {
    return new Withdraw__Params(this);
  }
}

export class Withdraw__Params {
  _event: Withdraw;

  constructor(event: Withdraw) {
    this._event = event;
  }

  get addr(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class WithdrawMultiplier extends ethereum.Event {
  get params(): WithdrawMultiplier__Params {
    return new WithdrawMultiplier__Params(this);
  }
}

export class WithdrawMultiplier__Params {
  _event: WithdrawMultiplier;

  constructor(event: WithdrawMultiplier) {
    this._event = event;
  }

  get addr(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get nft(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get tokenId(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get multipliedAmount(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class mUMAMI__marinatorInfoResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getAmount(): BigInt {
    return this.value0;
  }

  getMultipliedAmount(): BigInt {
    return this.value1;
  }
}

export class mUMAMI extends ethereum.SmartContract {
  static bind(address: Address): mUMAMI {
    return new mUMAMI("mUMAMI", address);
  }

  ADMIN_ROLE(): Bytes {
    let result = super.call("ADMIN_ROLE", "ADMIN_ROLE():(bytes32)", []);

    return result[0].toBytes();
  }

  try_ADMIN_ROLE(): ethereum.CallResult<Bytes> {
    let result = super.tryCall("ADMIN_ROLE", "ADMIN_ROLE():(bytes32)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  BASE(): BigInt {
    let result = super.call("BASE", "BASE():(uint256)", []);

    return result[0].toBigInt();
  }

  try_BASE(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("BASE", "BASE():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  DEFAULT_ADMIN_ROLE(): Bytes {
    let result = super.call(
      "DEFAULT_ADMIN_ROLE",
      "DEFAULT_ADMIN_ROLE():(bytes32)",
      []
    );

    return result[0].toBytes();
  }

  try_DEFAULT_ADMIN_ROLE(): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "DEFAULT_ADMIN_ROLE",
      "DEFAULT_ADMIN_ROLE():(bytes32)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  SCALE(): BigInt {
    let result = super.call("SCALE", "SCALE():(uint256)", []);

    return result[0].toBigInt();
  }

  try_SCALE(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("SCALE", "SCALE():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  UMAMI(): Address {
    let result = super.call("UMAMI", "UMAMI():(address)", []);

    return result[0].toAddress();
  }

  try_UMAMI(): ethereum.CallResult<Address> {
    let result = super.tryCall("UMAMI", "UMAMI():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  addToContractWhitelist(_contract: Address): boolean {
    let result = super.call(
      "addToContractWhitelist",
      "addToContractWhitelist(address):(bool)",
      [ethereum.Value.fromAddress(_contract)]
    );

    return result[0].toBoolean();
  }

  try_addToContractWhitelist(_contract: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "addToContractWhitelist",
      "addToContractWhitelist(address):(bool)",
      [ethereum.Value.fromAddress(_contract)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  allowance(owner: Address, spender: Address): BigInt {
    let result = super.call(
      "allowance",
      "allowance(address,address):(uint256)",
      [ethereum.Value.fromAddress(owner), ethereum.Value.fromAddress(spender)]
    );

    return result[0].toBigInt();
  }

  try_allowance(owner: Address, spender: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "allowance",
      "allowance(address,address):(uint256)",
      [ethereum.Value.fromAddress(owner), ethereum.Value.fromAddress(spender)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  approve(spender: Address, amount: BigInt): boolean {
    let result = super.call("approve", "approve(address,uint256):(bool)", [
      ethereum.Value.fromAddress(spender),
      ethereum.Value.fromUnsignedBigInt(amount)
    ]);

    return result[0].toBoolean();
  }

  try_approve(spender: Address, amount: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall("approve", "approve(address,uint256):(bool)", [
      ethereum.Value.fromAddress(spender),
      ethereum.Value.fromUnsignedBigInt(amount)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  balanceOf(account: Address): BigInt {
    let result = super.call("balanceOf", "balanceOf(address):(uint256)", [
      ethereum.Value.fromAddress(account)
    ]);

    return result[0].toBigInt();
  }

  try_balanceOf(account: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("balanceOf", "balanceOf(address):(uint256)", [
      ethereum.Value.fromAddress(account)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  decimals(): i32 {
    let result = super.call("decimals", "decimals():(uint8)", []);

    return result[0].toI32();
  }

  try_decimals(): ethereum.CallResult<i32> {
    let result = super.tryCall("decimals", "decimals():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  decreaseAllowance(spender: Address, subtractedValue: BigInt): boolean {
    let result = super.call(
      "decreaseAllowance",
      "decreaseAllowance(address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(spender),
        ethereum.Value.fromUnsignedBigInt(subtractedValue)
      ]
    );

    return result[0].toBoolean();
  }

  try_decreaseAllowance(
    spender: Address,
    subtractedValue: BigInt
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "decreaseAllowance",
      "decreaseAllowance(address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(spender),
        ethereum.Value.fromUnsignedBigInt(subtractedValue)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  depositLimit(): BigInt {
    let result = super.call("depositLimit", "depositLimit():(uint256)", []);

    return result[0].toBigInt();
  }

  try_depositLimit(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("depositLimit", "depositLimit():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getAvailableTokenRewards(staker: Address, token: Address): BigInt {
    let result = super.call(
      "getAvailableTokenRewards",
      "getAvailableTokenRewards(address,address):(uint256)",
      [ethereum.Value.fromAddress(staker), ethereum.Value.fromAddress(token)]
    );

    return result[0].toBigInt();
  }

  try_getAvailableTokenRewards(
    staker: Address,
    token: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getAvailableTokenRewards",
      "getAvailableTokenRewards(address,address):(uint256)",
      [ethereum.Value.fromAddress(staker), ethereum.Value.fromAddress(token)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getRoleAdmin(role: Bytes): Bytes {
    let result = super.call("getRoleAdmin", "getRoleAdmin(bytes32):(bytes32)", [
      ethereum.Value.fromFixedBytes(role)
    ]);

    return result[0].toBytes();
  }

  try_getRoleAdmin(role: Bytes): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "getRoleAdmin",
      "getRoleAdmin(bytes32):(bytes32)",
      [ethereum.Value.fromFixedBytes(role)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  hasRole(role: Bytes, account: Address): boolean {
    let result = super.call("hasRole", "hasRole(bytes32,address):(bool)", [
      ethereum.Value.fromFixedBytes(role),
      ethereum.Value.fromAddress(account)
    ]);

    return result[0].toBoolean();
  }

  try_hasRole(role: Bytes, account: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("hasRole", "hasRole(bytes32,address):(bool)", [
      ethereum.Value.fromFixedBytes(role),
      ethereum.Value.fromAddress(account)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  increaseAllowance(spender: Address, addedValue: BigInt): boolean {
    let result = super.call(
      "increaseAllowance",
      "increaseAllowance(address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(spender),
        ethereum.Value.fromUnsignedBigInt(addedValue)
      ]
    );

    return result[0].toBoolean();
  }

  try_increaseAllowance(
    spender: Address,
    addedValue: BigInt
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "increaseAllowance",
      "increaseAllowance(address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(spender),
        ethereum.Value.fromUnsignedBigInt(addedValue)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isApprovedMultiplierNFT(param0: Address): boolean {
    let result = super.call(
      "isApprovedMultiplierNFT",
      "isApprovedMultiplierNFT(address):(bool)",
      [ethereum.Value.fromAddress(param0)]
    );

    return result[0].toBoolean();
  }

  try_isApprovedMultiplierNFT(param0: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isApprovedMultiplierNFT",
      "isApprovedMultiplierNFT(address):(bool)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isApprovedRewardToken(param0: Address): boolean {
    let result = super.call(
      "isApprovedRewardToken",
      "isApprovedRewardToken(address):(bool)",
      [ethereum.Value.fromAddress(param0)]
    );

    return result[0].toBoolean();
  }

  try_isApprovedRewardToken(param0: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isApprovedRewardToken",
      "isApprovedRewardToken(address):(bool)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isContract(addr: Address): boolean {
    let result = super.call("isContract", "isContract(address):(bool)", [
      ethereum.Value.fromAddress(addr)
    ]);

    return result[0].toBoolean();
  }

  try_isContract(addr: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("isContract", "isContract(address):(bool)", [
      ethereum.Value.fromAddress(addr)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isNFTStaked(param0: Address, param1: Address): boolean {
    let result = super.call(
      "isNFTStaked",
      "isNFTStaked(address,address):(bool)",
      [ethereum.Value.fromAddress(param0), ethereum.Value.fromAddress(param1)]
    );

    return result[0].toBoolean();
  }

  try_isNFTStaked(
    param0: Address,
    param1: Address
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isNFTStaked",
      "isNFTStaked(address,address):(bool)",
      [ethereum.Value.fromAddress(param0), ethereum.Value.fromAddress(param1)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isWhitelisted(addr: Address): boolean {
    let result = super.call("isWhitelisted", "isWhitelisted(address):(bool)", [
      ethereum.Value.fromAddress(addr)
    ]);

    return result[0].toBoolean();
  }

  try_isWhitelisted(addr: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isWhitelisted",
      "isWhitelisted(address):(bool)",
      [ethereum.Value.fromAddress(addr)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  marinatorInfo(param0: Address): mUMAMI__marinatorInfoResult {
    let result = super.call(
      "marinatorInfo",
      "marinatorInfo(address):(uint256,uint256)",
      [ethereum.Value.fromAddress(param0)]
    );

    return new mUMAMI__marinatorInfoResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_marinatorInfo(
    param0: Address
  ): ethereum.CallResult<mUMAMI__marinatorInfoResult> {
    let result = super.tryCall(
      "marinatorInfo",
      "marinatorInfo(address):(uint256,uint256)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new mUMAMI__marinatorInfoResult(value[0].toBigInt(), value[1].toBigInt())
    );
  }

  multiplierNFTs(param0: BigInt): Address {
    let result = super.call(
      "multiplierNFTs",
      "multiplierNFTs(uint256):(address)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );

    return result[0].toAddress();
  }

  try_multiplierNFTs(param0: BigInt): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "multiplierNFTs",
      "multiplierNFTs(uint256):(address)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  multiplierStakingEnabled(): boolean {
    let result = super.call(
      "multiplierStakingEnabled",
      "multiplierStakingEnabled():(bool)",
      []
    );

    return result[0].toBoolean();
  }

  try_multiplierStakingEnabled(): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "multiplierStakingEnabled",
      "multiplierStakingEnabled():(bool)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  multiplierWithdrawEnabled(): boolean {
    let result = super.call(
      "multiplierWithdrawEnabled",
      "multiplierWithdrawEnabled():(bool)",
      []
    );

    return result[0].toBoolean();
  }

  try_multiplierWithdrawEnabled(): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "multiplierWithdrawEnabled",
      "multiplierWithdrawEnabled():(bool)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  name(): string {
    let result = super.call("name", "name():(string)", []);

    return result[0].toString();
  }

  try_name(): ethereum.CallResult<string> {
    let result = super.tryCall("name", "name():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  nftMultiplier(param0: Address): BigInt {
    let result = super.call(
      "nftMultiplier",
      "nftMultiplier(address):(uint256)",
      [ethereum.Value.fromAddress(param0)]
    );

    return result[0].toBigInt();
  }

  try_nftMultiplier(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "nftMultiplier",
      "nftMultiplier(address):(uint256)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  onERC721Received(
    param0: Address,
    param1: Address,
    param2: BigInt,
    param3: Bytes
  ): Bytes {
    let result = super.call(
      "onERC721Received",
      "onERC721Received(address,address,uint256,bytes):(bytes4)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromUnsignedBigInt(param2),
        ethereum.Value.fromBytes(param3)
      ]
    );

    return result[0].toBytes();
  }

  try_onERC721Received(
    param0: Address,
    param1: Address,
    param2: BigInt,
    param3: Bytes
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "onERC721Received",
      "onERC721Received(address,address,uint256,bytes):(bytes4)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromUnsignedBigInt(param2),
        ethereum.Value.fromBytes(param3)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  owner(): Address {
    let result = super.call("owner", "owner():(address)", []);

    return result[0].toAddress();
  }

  try_owner(): ethereum.CallResult<Address> {
    let result = super.tryCall("owner", "owner():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  paidTokenRewardsPerStake(param0: Address, param1: Address): BigInt {
    let result = super.call(
      "paidTokenRewardsPerStake",
      "paidTokenRewardsPerStake(address,address):(uint256)",
      [ethereum.Value.fromAddress(param0), ethereum.Value.fromAddress(param1)]
    );

    return result[0].toBigInt();
  }

  try_paidTokenRewardsPerStake(
    param0: Address,
    param1: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "paidTokenRewardsPerStake",
      "paidTokenRewardsPerStake(address,address):(uint256)",
      [ethereum.Value.fromAddress(param0), ethereum.Value.fromAddress(param1)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  payRewardsEnabled(): boolean {
    let result = super.call(
      "payRewardsEnabled",
      "payRewardsEnabled():(bool)",
      []
    );

    return result[0].toBoolean();
  }

  try_payRewardsEnabled(): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "payRewardsEnabled",
      "payRewardsEnabled():(bool)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  removeFromContractWhitelist(_contract: Address): boolean {
    let result = super.call(
      "removeFromContractWhitelist",
      "removeFromContractWhitelist(address):(bool)",
      [ethereum.Value.fromAddress(_contract)]
    );

    return result[0].toBoolean();
  }

  try_removeFromContractWhitelist(
    _contract: Address
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "removeFromContractWhitelist",
      "removeFromContractWhitelist(address):(bool)",
      [ethereum.Value.fromAddress(_contract)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  rewardTokens(param0: BigInt): Address {
    let result = super.call("rewardTokens", "rewardTokens(uint256):(address)", [
      ethereum.Value.fromUnsignedBigInt(param0)
    ]);

    return result[0].toAddress();
  }

  try_rewardTokens(param0: BigInt): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "rewardTokens",
      "rewardTokens(uint256):(address)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  stakeEnabled(): boolean {
    let result = super.call("stakeEnabled", "stakeEnabled():(bool)", []);

    return result[0].toBoolean();
  }

  try_stakeEnabled(): ethereum.CallResult<boolean> {
    let result = super.tryCall("stakeEnabled", "stakeEnabled():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  supportsInterface(interfaceId: Bytes): boolean {
    let result = super.call(
      "supportsInterface",
      "supportsInterface(bytes4):(bool)",
      [ethereum.Value.fromFixedBytes(interfaceId)]
    );

    return result[0].toBoolean();
  }

  try_supportsInterface(interfaceId: Bytes): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "supportsInterface",
      "supportsInterface(bytes4):(bool)",
      [ethereum.Value.fromFixedBytes(interfaceId)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  symbol(): string {
    let result = super.call("symbol", "symbol():(string)", []);

    return result[0].toString();
  }

  try_symbol(): ethereum.CallResult<string> {
    let result = super.tryCall("symbol", "symbol():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  toBePaid(param0: Address, param1: Address): BigInt {
    let result = super.call("toBePaid", "toBePaid(address,address):(uint256)", [
      ethereum.Value.fromAddress(param0),
      ethereum.Value.fromAddress(param1)
    ]);

    return result[0].toBigInt();
  }

  try_toBePaid(param0: Address, param1: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "toBePaid",
      "toBePaid(address,address):(uint256)",
      [ethereum.Value.fromAddress(param0), ethereum.Value.fromAddress(param1)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  totalMultipliedStaked(): BigInt {
    let result = super.call(
      "totalMultipliedStaked",
      "totalMultipliedStaked():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_totalMultipliedStaked(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "totalMultipliedStaked",
      "totalMultipliedStaked():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  totalStaked(): BigInt {
    let result = super.call("totalStaked", "totalStaked():(uint256)", []);

    return result[0].toBigInt();
  }

  try_totalStaked(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("totalStaked", "totalStaked():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  totalSupply(): BigInt {
    let result = super.call("totalSupply", "totalSupply():(uint256)", []);

    return result[0].toBigInt();
  }

  try_totalSupply(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("totalSupply", "totalSupply():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  totalTokenRewardsPerStake(param0: Address): BigInt {
    let result = super.call(
      "totalTokenRewardsPerStake",
      "totalTokenRewardsPerStake(address):(uint256)",
      [ethereum.Value.fromAddress(param0)]
    );

    return result[0].toBigInt();
  }

  try_totalTokenRewardsPerStake(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "totalTokenRewardsPerStake",
      "totalTokenRewardsPerStake(address):(uint256)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  transfer(recipient: Address, amount: BigInt): boolean {
    let result = super.call("transfer", "transfer(address,uint256):(bool)", [
      ethereum.Value.fromAddress(recipient),
      ethereum.Value.fromUnsignedBigInt(amount)
    ]);

    return result[0].toBoolean();
  }

  try_transfer(
    recipient: Address,
    amount: BigInt
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall("transfer", "transfer(address,uint256):(bool)", [
      ethereum.Value.fromAddress(recipient),
      ethereum.Value.fromUnsignedBigInt(amount)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  transferEnabled(): boolean {
    let result = super.call("transferEnabled", "transferEnabled():(bool)", []);

    return result[0].toBoolean();
  }

  try_transferEnabled(): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "transferEnabled",
      "transferEnabled():(bool)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  transferFrom(sender: Address, recipient: Address, amount: BigInt): boolean {
    let result = super.call(
      "transferFrom",
      "transferFrom(address,address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(sender),
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromUnsignedBigInt(amount)
      ]
    );

    return result[0].toBoolean();
  }

  try_transferFrom(
    sender: Address,
    recipient: Address,
    amount: BigInt
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "transferFrom",
      "transferFrom(address,address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(sender),
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromUnsignedBigInt(amount)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  whitelistedContracts(param0: Address): boolean {
    let result = super.call(
      "whitelistedContracts",
      "whitelistedContracts(address):(bool)",
      [ethereum.Value.fromAddress(param0)]
    );

    return result[0].toBoolean();
  }

  try_whitelistedContracts(param0: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "whitelistedContracts",
      "whitelistedContracts(address):(bool)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  withdrawEnabled(): boolean {
    let result = super.call("withdrawEnabled", "withdrawEnabled():(bool)", []);

    return result[0].toBoolean();
  }

  try_withdrawEnabled(): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "withdrawEnabled",
      "withdrawEnabled():(bool)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get _UMAMI(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get name(): string {
    return this._call.inputValues[1].value.toString();
  }

  get symbol(): string {
    return this._call.inputValues[2].value.toString();
  }

  get _depositLimit(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class AddApprovedMultiplierTokenCall extends ethereum.Call {
  get inputs(): AddApprovedMultiplierTokenCall__Inputs {
    return new AddApprovedMultiplierTokenCall__Inputs(this);
  }

  get outputs(): AddApprovedMultiplierTokenCall__Outputs {
    return new AddApprovedMultiplierTokenCall__Outputs(this);
  }
}

export class AddApprovedMultiplierTokenCall__Inputs {
  _call: AddApprovedMultiplierTokenCall;

  constructor(call: AddApprovedMultiplierTokenCall) {
    this._call = call;
  }

  get token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get multiplier(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class AddApprovedMultiplierTokenCall__Outputs {
  _call: AddApprovedMultiplierTokenCall;

  constructor(call: AddApprovedMultiplierTokenCall) {
    this._call = call;
  }
}

export class AddApprovedRewardTokenCall extends ethereum.Call {
  get inputs(): AddApprovedRewardTokenCall__Inputs {
    return new AddApprovedRewardTokenCall__Inputs(this);
  }

  get outputs(): AddApprovedRewardTokenCall__Outputs {
    return new AddApprovedRewardTokenCall__Outputs(this);
  }
}

export class AddApprovedRewardTokenCall__Inputs {
  _call: AddApprovedRewardTokenCall;

  constructor(call: AddApprovedRewardTokenCall) {
    this._call = call;
  }

  get token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class AddApprovedRewardTokenCall__Outputs {
  _call: AddApprovedRewardTokenCall;

  constructor(call: AddApprovedRewardTokenCall) {
    this._call = call;
  }
}

export class AddRewardCall extends ethereum.Call {
  get inputs(): AddRewardCall__Inputs {
    return new AddRewardCall__Inputs(this);
  }

  get outputs(): AddRewardCall__Outputs {
    return new AddRewardCall__Outputs(this);
  }
}

export class AddRewardCall__Inputs {
  _call: AddRewardCall;

  constructor(call: AddRewardCall) {
    this._call = call;
  }

  get token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class AddRewardCall__Outputs {
  _call: AddRewardCall;

  constructor(call: AddRewardCall) {
    this._call = call;
  }
}

export class AddToContractWhitelistCall extends ethereum.Call {
  get inputs(): AddToContractWhitelistCall__Inputs {
    return new AddToContractWhitelistCall__Inputs(this);
  }

  get outputs(): AddToContractWhitelistCall__Outputs {
    return new AddToContractWhitelistCall__Outputs(this);
  }
}

export class AddToContractWhitelistCall__Inputs {
  _call: AddToContractWhitelistCall;

  constructor(call: AddToContractWhitelistCall) {
    this._call = call;
  }

  get _contract(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class AddToContractWhitelistCall__Outputs {
  _call: AddToContractWhitelistCall;

  constructor(call: AddToContractWhitelistCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class ApproveCall extends ethereum.Call {
  get inputs(): ApproveCall__Inputs {
    return new ApproveCall__Inputs(this);
  }

  get outputs(): ApproveCall__Outputs {
    return new ApproveCall__Outputs(this);
  }
}

export class ApproveCall__Inputs {
  _call: ApproveCall;

  constructor(call: ApproveCall) {
    this._call = call;
  }

  get spender(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class ApproveCall__Outputs {
  _call: ApproveCall;

  constructor(call: ApproveCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class ClaimRewardsCall extends ethereum.Call {
  get inputs(): ClaimRewardsCall__Inputs {
    return new ClaimRewardsCall__Inputs(this);
  }

  get outputs(): ClaimRewardsCall__Outputs {
    return new ClaimRewardsCall__Outputs(this);
  }
}

export class ClaimRewardsCall__Inputs {
  _call: ClaimRewardsCall;

  constructor(call: ClaimRewardsCall) {
    this._call = call;
  }
}

export class ClaimRewardsCall__Outputs {
  _call: ClaimRewardsCall;

  constructor(call: ClaimRewardsCall) {
    this._call = call;
  }
}

export class DecreaseAllowanceCall extends ethereum.Call {
  get inputs(): DecreaseAllowanceCall__Inputs {
    return new DecreaseAllowanceCall__Inputs(this);
  }

  get outputs(): DecreaseAllowanceCall__Outputs {
    return new DecreaseAllowanceCall__Outputs(this);
  }
}

export class DecreaseAllowanceCall__Inputs {
  _call: DecreaseAllowanceCall;

  constructor(call: DecreaseAllowanceCall) {
    this._call = call;
  }

  get spender(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get subtractedValue(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class DecreaseAllowanceCall__Outputs {
  _call: DecreaseAllowanceCall;

  constructor(call: DecreaseAllowanceCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class GrantRoleCall extends ethereum.Call {
  get inputs(): GrantRoleCall__Inputs {
    return new GrantRoleCall__Inputs(this);
  }

  get outputs(): GrantRoleCall__Outputs {
    return new GrantRoleCall__Outputs(this);
  }
}

export class GrantRoleCall__Inputs {
  _call: GrantRoleCall;

  constructor(call: GrantRoleCall) {
    this._call = call;
  }

  get role(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get account(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class GrantRoleCall__Outputs {
  _call: GrantRoleCall;

  constructor(call: GrantRoleCall) {
    this._call = call;
  }
}

export class IncreaseAllowanceCall extends ethereum.Call {
  get inputs(): IncreaseAllowanceCall__Inputs {
    return new IncreaseAllowanceCall__Inputs(this);
  }

  get outputs(): IncreaseAllowanceCall__Outputs {
    return new IncreaseAllowanceCall__Outputs(this);
  }
}

export class IncreaseAllowanceCall__Inputs {
  _call: IncreaseAllowanceCall;

  constructor(call: IncreaseAllowanceCall) {
    this._call = call;
  }

  get spender(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get addedValue(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class IncreaseAllowanceCall__Outputs {
  _call: IncreaseAllowanceCall;

  constructor(call: IncreaseAllowanceCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class MigrateTokenCall extends ethereum.Call {
  get inputs(): MigrateTokenCall__Inputs {
    return new MigrateTokenCall__Inputs(this);
  }

  get outputs(): MigrateTokenCall__Outputs {
    return new MigrateTokenCall__Outputs(this);
  }
}

export class MigrateTokenCall__Inputs {
  _call: MigrateTokenCall;

  constructor(call: MigrateTokenCall) {
    this._call = call;
  }

  get token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get destination(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class MigrateTokenCall__Outputs {
  _call: MigrateTokenCall;

  constructor(call: MigrateTokenCall) {
    this._call = call;
  }
}

export class RecoverEthCall extends ethereum.Call {
  get inputs(): RecoverEthCall__Inputs {
    return new RecoverEthCall__Inputs(this);
  }

  get outputs(): RecoverEthCall__Outputs {
    return new RecoverEthCall__Outputs(this);
  }
}

export class RecoverEthCall__Inputs {
  _call: RecoverEthCall;

  constructor(call: RecoverEthCall) {
    this._call = call;
  }
}

export class RecoverEthCall__Outputs {
  _call: RecoverEthCall;

  constructor(call: RecoverEthCall) {
    this._call = call;
  }
}

export class RemoveApprovedMultiplierTokenCall extends ethereum.Call {
  get inputs(): RemoveApprovedMultiplierTokenCall__Inputs {
    return new RemoveApprovedMultiplierTokenCall__Inputs(this);
  }

  get outputs(): RemoveApprovedMultiplierTokenCall__Outputs {
    return new RemoveApprovedMultiplierTokenCall__Outputs(this);
  }
}

export class RemoveApprovedMultiplierTokenCall__Inputs {
  _call: RemoveApprovedMultiplierTokenCall;

  constructor(call: RemoveApprovedMultiplierTokenCall) {
    this._call = call;
  }

  get token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class RemoveApprovedMultiplierTokenCall__Outputs {
  _call: RemoveApprovedMultiplierTokenCall;

  constructor(call: RemoveApprovedMultiplierTokenCall) {
    this._call = call;
  }
}

export class RemoveApprovedRewardTokenCall extends ethereum.Call {
  get inputs(): RemoveApprovedRewardTokenCall__Inputs {
    return new RemoveApprovedRewardTokenCall__Inputs(this);
  }

  get outputs(): RemoveApprovedRewardTokenCall__Outputs {
    return new RemoveApprovedRewardTokenCall__Outputs(this);
  }
}

export class RemoveApprovedRewardTokenCall__Inputs {
  _call: RemoveApprovedRewardTokenCall;

  constructor(call: RemoveApprovedRewardTokenCall) {
    this._call = call;
  }

  get token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class RemoveApprovedRewardTokenCall__Outputs {
  _call: RemoveApprovedRewardTokenCall;

  constructor(call: RemoveApprovedRewardTokenCall) {
    this._call = call;
  }
}

export class RemoveFromContractWhitelistCall extends ethereum.Call {
  get inputs(): RemoveFromContractWhitelistCall__Inputs {
    return new RemoveFromContractWhitelistCall__Inputs(this);
  }

  get outputs(): RemoveFromContractWhitelistCall__Outputs {
    return new RemoveFromContractWhitelistCall__Outputs(this);
  }
}

export class RemoveFromContractWhitelistCall__Inputs {
  _call: RemoveFromContractWhitelistCall;

  constructor(call: RemoveFromContractWhitelistCall) {
    this._call = call;
  }

  get _contract(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class RemoveFromContractWhitelistCall__Outputs {
  _call: RemoveFromContractWhitelistCall;

  constructor(call: RemoveFromContractWhitelistCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class RenounceOwnershipCall extends ethereum.Call {
  get inputs(): RenounceOwnershipCall__Inputs {
    return new RenounceOwnershipCall__Inputs(this);
  }

  get outputs(): RenounceOwnershipCall__Outputs {
    return new RenounceOwnershipCall__Outputs(this);
  }
}

export class RenounceOwnershipCall__Inputs {
  _call: RenounceOwnershipCall;

  constructor(call: RenounceOwnershipCall) {
    this._call = call;
  }
}

export class RenounceOwnershipCall__Outputs {
  _call: RenounceOwnershipCall;

  constructor(call: RenounceOwnershipCall) {
    this._call = call;
  }
}

export class RenounceRoleCall extends ethereum.Call {
  get inputs(): RenounceRoleCall__Inputs {
    return new RenounceRoleCall__Inputs(this);
  }

  get outputs(): RenounceRoleCall__Outputs {
    return new RenounceRoleCall__Outputs(this);
  }
}

export class RenounceRoleCall__Inputs {
  _call: RenounceRoleCall;

  constructor(call: RenounceRoleCall) {
    this._call = call;
  }

  get role(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get account(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class RenounceRoleCall__Outputs {
  _call: RenounceRoleCall;

  constructor(call: RenounceRoleCall) {
    this._call = call;
  }
}

export class RevokeRoleCall extends ethereum.Call {
  get inputs(): RevokeRoleCall__Inputs {
    return new RevokeRoleCall__Inputs(this);
  }

  get outputs(): RevokeRoleCall__Outputs {
    return new RevokeRoleCall__Outputs(this);
  }
}

export class RevokeRoleCall__Inputs {
  _call: RevokeRoleCall;

  constructor(call: RevokeRoleCall) {
    this._call = call;
  }

  get role(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get account(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class RevokeRoleCall__Outputs {
  _call: RevokeRoleCall;

  constructor(call: RevokeRoleCall) {
    this._call = call;
  }
}

export class SetDepositLimitCall extends ethereum.Call {
  get inputs(): SetDepositLimitCall__Inputs {
    return new SetDepositLimitCall__Inputs(this);
  }

  get outputs(): SetDepositLimitCall__Outputs {
    return new SetDepositLimitCall__Outputs(this);
  }
}

export class SetDepositLimitCall__Inputs {
  _call: SetDepositLimitCall;

  constructor(call: SetDepositLimitCall) {
    this._call = call;
  }

  get limit(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class SetDepositLimitCall__Outputs {
  _call: SetDepositLimitCall;

  constructor(call: SetDepositLimitCall) {
    this._call = call;
  }
}

export class SetMultiplierStakeEnabledCall extends ethereum.Call {
  get inputs(): SetMultiplierStakeEnabledCall__Inputs {
    return new SetMultiplierStakeEnabledCall__Inputs(this);
  }

  get outputs(): SetMultiplierStakeEnabledCall__Outputs {
    return new SetMultiplierStakeEnabledCall__Outputs(this);
  }
}

export class SetMultiplierStakeEnabledCall__Inputs {
  _call: SetMultiplierStakeEnabledCall;

  constructor(call: SetMultiplierStakeEnabledCall) {
    this._call = call;
  }

  get enabled(): boolean {
    return this._call.inputValues[0].value.toBoolean();
  }
}

export class SetMultiplierStakeEnabledCall__Outputs {
  _call: SetMultiplierStakeEnabledCall;

  constructor(call: SetMultiplierStakeEnabledCall) {
    this._call = call;
  }
}

export class SetMultiplierWithdrawEnabledCall extends ethereum.Call {
  get inputs(): SetMultiplierWithdrawEnabledCall__Inputs {
    return new SetMultiplierWithdrawEnabledCall__Inputs(this);
  }

  get outputs(): SetMultiplierWithdrawEnabledCall__Outputs {
    return new SetMultiplierWithdrawEnabledCall__Outputs(this);
  }
}

export class SetMultiplierWithdrawEnabledCall__Inputs {
  _call: SetMultiplierWithdrawEnabledCall;

  constructor(call: SetMultiplierWithdrawEnabledCall) {
    this._call = call;
  }

  get enabled(): boolean {
    return this._call.inputValues[0].value.toBoolean();
  }
}

export class SetMultiplierWithdrawEnabledCall__Outputs {
  _call: SetMultiplierWithdrawEnabledCall;

  constructor(call: SetMultiplierWithdrawEnabledCall) {
    this._call = call;
  }
}

export class SetPayRewardsEnabledCall extends ethereum.Call {
  get inputs(): SetPayRewardsEnabledCall__Inputs {
    return new SetPayRewardsEnabledCall__Inputs(this);
  }

  get outputs(): SetPayRewardsEnabledCall__Outputs {
    return new SetPayRewardsEnabledCall__Outputs(this);
  }
}

export class SetPayRewardsEnabledCall__Inputs {
  _call: SetPayRewardsEnabledCall;

  constructor(call: SetPayRewardsEnabledCall) {
    this._call = call;
  }

  get enabled(): boolean {
    return this._call.inputValues[0].value.toBoolean();
  }
}

export class SetPayRewardsEnabledCall__Outputs {
  _call: SetPayRewardsEnabledCall;

  constructor(call: SetPayRewardsEnabledCall) {
    this._call = call;
  }
}

export class SetScaleCall extends ethereum.Call {
  get inputs(): SetScaleCall__Inputs {
    return new SetScaleCall__Inputs(this);
  }

  get outputs(): SetScaleCall__Outputs {
    return new SetScaleCall__Outputs(this);
  }
}

export class SetScaleCall__Inputs {
  _call: SetScaleCall;

  constructor(call: SetScaleCall) {
    this._call = call;
  }

  get _scale(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class SetScaleCall__Outputs {
  _call: SetScaleCall;

  constructor(call: SetScaleCall) {
    this._call = call;
  }
}

export class SetStakeEnabledCall extends ethereum.Call {
  get inputs(): SetStakeEnabledCall__Inputs {
    return new SetStakeEnabledCall__Inputs(this);
  }

  get outputs(): SetStakeEnabledCall__Outputs {
    return new SetStakeEnabledCall__Outputs(this);
  }
}

export class SetStakeEnabledCall__Inputs {
  _call: SetStakeEnabledCall;

  constructor(call: SetStakeEnabledCall) {
    this._call = call;
  }

  get enabled(): boolean {
    return this._call.inputValues[0].value.toBoolean();
  }
}

export class SetStakeEnabledCall__Outputs {
  _call: SetStakeEnabledCall;

  constructor(call: SetStakeEnabledCall) {
    this._call = call;
  }
}

export class SetStakingWithdrawEnabledCall extends ethereum.Call {
  get inputs(): SetStakingWithdrawEnabledCall__Inputs {
    return new SetStakingWithdrawEnabledCall__Inputs(this);
  }

  get outputs(): SetStakingWithdrawEnabledCall__Outputs {
    return new SetStakingWithdrawEnabledCall__Outputs(this);
  }
}

export class SetStakingWithdrawEnabledCall__Inputs {
  _call: SetStakingWithdrawEnabledCall;

  constructor(call: SetStakingWithdrawEnabledCall) {
    this._call = call;
  }

  get enabled(): boolean {
    return this._call.inputValues[0].value.toBoolean();
  }
}

export class SetStakingWithdrawEnabledCall__Outputs {
  _call: SetStakingWithdrawEnabledCall;

  constructor(call: SetStakingWithdrawEnabledCall) {
    this._call = call;
  }
}

export class SetTransferEnabledCall extends ethereum.Call {
  get inputs(): SetTransferEnabledCall__Inputs {
    return new SetTransferEnabledCall__Inputs(this);
  }

  get outputs(): SetTransferEnabledCall__Outputs {
    return new SetTransferEnabledCall__Outputs(this);
  }
}

export class SetTransferEnabledCall__Inputs {
  _call: SetTransferEnabledCall;

  constructor(call: SetTransferEnabledCall) {
    this._call = call;
  }

  get enabled(): boolean {
    return this._call.inputValues[0].value.toBoolean();
  }
}

export class SetTransferEnabledCall__Outputs {
  _call: SetTransferEnabledCall;

  constructor(call: SetTransferEnabledCall) {
    this._call = call;
  }
}

export class StakeCall extends ethereum.Call {
  get inputs(): StakeCall__Inputs {
    return new StakeCall__Inputs(this);
  }

  get outputs(): StakeCall__Outputs {
    return new StakeCall__Outputs(this);
  }
}

export class StakeCall__Inputs {
  _call: StakeCall;

  constructor(call: StakeCall) {
    this._call = call;
  }

  get amount(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class StakeCall__Outputs {
  _call: StakeCall;

  constructor(call: StakeCall) {
    this._call = call;
  }
}

export class StakeMultiplierCall extends ethereum.Call {
  get inputs(): StakeMultiplierCall__Inputs {
    return new StakeMultiplierCall__Inputs(this);
  }

  get outputs(): StakeMultiplierCall__Outputs {
    return new StakeMultiplierCall__Outputs(this);
  }
}

export class StakeMultiplierCall__Inputs {
  _call: StakeMultiplierCall;

  constructor(call: StakeMultiplierCall) {
    this._call = call;
  }

  get nft(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get tokenId(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class StakeMultiplierCall__Outputs {
  _call: StakeMultiplierCall;

  constructor(call: StakeMultiplierCall) {
    this._call = call;
  }
}

export class TransferCall extends ethereum.Call {
  get inputs(): TransferCall__Inputs {
    return new TransferCall__Inputs(this);
  }

  get outputs(): TransferCall__Outputs {
    return new TransferCall__Outputs(this);
  }
}

export class TransferCall__Inputs {
  _call: TransferCall;

  constructor(call: TransferCall) {
    this._call = call;
  }

  get recipient(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class TransferCall__Outputs {
  _call: TransferCall;

  constructor(call: TransferCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class TransferFromCall extends ethereum.Call {
  get inputs(): TransferFromCall__Inputs {
    return new TransferFromCall__Inputs(this);
  }

  get outputs(): TransferFromCall__Outputs {
    return new TransferFromCall__Outputs(this);
  }
}

export class TransferFromCall__Inputs {
  _call: TransferFromCall;

  constructor(call: TransferFromCall) {
    this._call = call;
  }

  get sender(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get recipient(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class TransferFromCall__Outputs {
  _call: TransferFromCall;

  constructor(call: TransferFromCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class TransferOwnershipCall extends ethereum.Call {
  get inputs(): TransferOwnershipCall__Inputs {
    return new TransferOwnershipCall__Inputs(this);
  }

  get outputs(): TransferOwnershipCall__Outputs {
    return new TransferOwnershipCall__Outputs(this);
  }
}

export class TransferOwnershipCall__Inputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }

  get newOwner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class TransferOwnershipCall__Outputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }
}

export class WithdrawCall extends ethereum.Call {
  get inputs(): WithdrawCall__Inputs {
    return new WithdrawCall__Inputs(this);
  }

  get outputs(): WithdrawCall__Outputs {
    return new WithdrawCall__Outputs(this);
  }
}

export class WithdrawCall__Inputs {
  _call: WithdrawCall;

  constructor(call: WithdrawCall) {
    this._call = call;
  }
}

export class WithdrawCall__Outputs {
  _call: WithdrawCall;

  constructor(call: WithdrawCall) {
    this._call = call;
  }
}

export class WithdrawMultiplierCall extends ethereum.Call {
  get inputs(): WithdrawMultiplierCall__Inputs {
    return new WithdrawMultiplierCall__Inputs(this);
  }

  get outputs(): WithdrawMultiplierCall__Outputs {
    return new WithdrawMultiplierCall__Outputs(this);
  }
}

export class WithdrawMultiplierCall__Inputs {
  _call: WithdrawMultiplierCall;

  constructor(call: WithdrawMultiplierCall) {
    this._call = call;
  }

  get nft(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get tokenId(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class WithdrawMultiplierCall__Outputs {
  _call: WithdrawMultiplierCall;

  constructor(call: WithdrawMultiplierCall) {
    this._call = call;
  }
}
